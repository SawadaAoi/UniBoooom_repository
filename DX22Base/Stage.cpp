/* ========================================
	HEW/UniBoooom!!
	---------------------------------------
	ステージ用抽象クラス実装
	!memo：当たり判定関連の処理はCollisionOfStage.cppに記載
	---------------------------------------
	Stage.cpp

	作成者
			takagi
			nieda

	変更履歴
	・2023/11/16 制作 takagi
	・2023/12/01 サウンドの読み込み yamashita
	・2023/12/04 ポーズクラス追加・デストラクタ復活 takagi
	・2023/12/05 コメント修正 takagi
	・2023/12/06 pose→pause修正、ポーズ文字表示 takagi
	・2023/12/14 BGMの管理をSceneManagerに移動 yamashita
	・2023/12/15 ゲームスタート表示書き変えに伴い必要なくなった変数削除 nieda
	・2023/12/15 フェード削除 takagi
	・2023/12/18 ポーズ動的確保 takagi
	・2023/12/28 BattleData格納処理をまとめた関数を追加	Sawada
	・2024/01/01 ステージ分岐 Takagi
	・2024/01/25 ヒットエフェクト関係の処理追加 Tei
	・2024/01/30 プレイヤー移動エフェクト関係の処理追加 Tei
	・2024/02/02 汗エフェクト処理追加 Tei
	・2024/02/09 UsingCamera使用 takagi

========================================== */

// =============== インクルード ===================
#include "Stage.h"	//自身のヘッダ
#include "Line.h"
#include "Stage1.h"	//ステージ1
#include "Stage2.h"	//ステージ2
#include "Stage3.h"	//ステージ3
#include "HitStop.h"	//ヒットストップ
#include "Fade.h"
#include "UsingCamera.h"	//カメラ使用


//* ========================================
//	コンストラクタ
//	----------------------------------------
//	内容：生成時に行う処理
//	----------------------------------------
//	引数1：CUIStageManager::E_STAGE_NUM eStage：ステージ番号
//	----------------------------------------
//	戻値：なし
//=========================================== */
CStage::CStage(CUIStageManager::E_STAGE_NUM eStage)
	: m_pVs(nullptr)
	, m_pPlayer(nullptr)
	, m_pBox(nullptr)
	, m_pSlimeMng(nullptr)
	, m_pCollision(nullptr)
	, m_pExplosionMng(nullptr)
	, m_pFloor(nullptr)
	, m_pTexture(nullptr)
	, m_pScoreOHMng(nullptr)
	, m_pHealItemMng(nullptr)
	, m_pUIStageManager(nullptr)
	, m_pPause(nullptr)	//ポーズ
	, m_pSEHitHammer(nullptr)
	, m_pSEHitHammerSpeaker(nullptr)
	, m_nStageNum(0)
{
	// 頂点シェーダの読込
	m_pVs = new VertexShader();
	if (FAILED(m_pVs->Load("Assets/shader/VS_Model.cso"))) {
		MessageBox(nullptr, "VS_Model.cso", "Error", MB_OK);
	}

	// レンダーターゲット、深度バッファの設定
	RenderTarget* pRTV = GetDefaultRTV();	//デフォルトで使用しているRenderTargetViewの取得
	DepthStencil* pDSV = GetDefaultDSV();	//デフォルトで使用しているDepthStencilViewの取得
	SetRenderTargets(1, &pRTV, pDSV);		//DSVがnullだと2D表示になる
	
	//================3dObject動的確保================
	m_pPlayer = new CPlayer();							// プレイヤー生成
	m_pExplosionMng = new CExplosionManager();			// 爆発マネージャー生成
	m_pSlimeMng = new CSlimeManager(m_pPlayer);			// スライムマネージャー生成
	m_pHealItemMng = new CHealItemManager();			// 回復アイテムマネージャー生成

	//================System動的確保================
	m_pMainCamera = std::make_shared<CCameraChase>();												//カメラ生成
	std::static_pointer_cast<CCameraChase>(m_pMainCamera)->SetTarget(m_pPlayer->GetPosAddress());	//注視点設定
	CUsingCamera::GetThis().SetCamera(m_pMainCamera);												//カメラ登録
	m_pCollision = new CCOLLISION();																//衝突判定チェック生成

	//================2dObject動的確保================
	m_pUIStageManager = new CUIStageManager(m_pPlayer, m_pSlimeMng, eStage);	// UIマネージャー生成
	m_pStartText = new CStartText();

	//================エフェクト動的確保================
	m_pHitEffectMng = new CHitSlimeEffectManager();

	m_pPause = new CPause();

	//スライムマネージャー　←　スコアマネージャー
	m_pSlimeMng->SetScoreOHMng(m_pUIStageManager->GetScoreOHMngPtr());

	//爆発マネージャー　←　コンボ
	m_pExplosionMng->SetCombo(m_pUIStageManager->GetComboPtr());

	//スライムマネージャー　←　爆発マネージャー
	m_pSlimeMng->SetExplosionMng(m_pExplosionMng);

	// スライムマネージャー　←　回復アイテムマネージャ―
	m_pSlimeMng->SetHealMng(m_pHealItemMng);

	//爆発マネージャー　←　タイマー
	m_pSlimeMng->SetTimer(m_pUIStageManager->GetTimerPtr());

	// データ受け継ぎ
	m_Data.Load();	//ファイルに上がっている情報を読み込む


}

/* ========================================
	更新関数
	----------------------------------------
	内容：更新処理
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
void CStage::Update()
{
	if (m_pStartText->GetAnimFlg())	// シーン遷移後ゲームを開始するか判定
	{
		m_pStartText->Update();
	}
	else
	{
		// カメラ更新
		m_pCamera->Update();

		// ボス警告表示中は停止
		if (m_pUIStageManager->GetShowWarningPtr()->GetDispFlg())
		{
			m_pUIStageManager->GetShowWarningPtr()->Update();	// 警告のみ更新

			return;
		}

		//ポーズ更新
		if (m_pPause)	//ヌルチェック
		{
			m_pPause->Update();	//ポーズ更新
			if (m_pPause->IsPause())	//ポーズ中
			{
				return;	//処理中断
			}
			m_bFinish = m_pPause->IsFin();	//終了判定
		}

		// =============== ヒットストップ検査 ===================
		if (!CHitStop::IsStop())	//ヒットストップ時処理しない
		{
			// プレイヤー更新
			m_pPlayer->Update();	//※カメラ更新含

			// スライムマネージャー更新
			m_pSlimeMng->Update(m_pExplosionMng);
		}

		m_pFloor->Update();				// 床更新
		m_pExplosionMng->Update();		// 爆発マネージャー更新
		m_pHealItemMng->Update();		// 回復アイテム更新
		m_pUIStageManager->Update();	// UIマネージャー更新
		PlayerHealItemCollision();		// 回復アイテム取る判定
		Collision();					// 当たり判定更新
		m_pHitEffectMng->Update();		// ヒットエフェクトマネージャー更新

	}

#if SCENE_TRANSITION
	if (m_pUIStageManager->GetStageFinishPtr()->GetDispFlg())
	{
		if (IsKeyTrigger(VK_RETURN) || IsKeyTriggerController(BUTTON_A))
		{
			m_bFinish = true;	// タイトルシーン終了フラグON
		}
	}
#else
	CStage::GameFinish();	// ステージ終了処理
#endif
}


/* ========================================
	描画関数
	----------------------------------------
	内容：描画処理
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
void CStage::Draw()
{
	RenderTarget* pRTV = GetDefaultRTV();	//デフォルトで使用しているRenderTargetViewの取得
	DepthStencil* pDSV = GetDefaultDSV();	//デフォルトで使用しているDepthStencilViewの取得
	SetRenderTargets(1, &pRTV, pDSV);		//DSVがnullだと2D表示になる

	//床の描画
	m_pFloor->Draw();

	// スライムマネージャー描画
	m_pSlimeMng->Draw();

	// プレイヤー描画
	m_pPlayer->Draw();

	LibEffekseer::Draw();

	//爆発マネージャー描画
	m_pExplosionMng->Draw();

	//回復アイテム描画
	m_pHealItemMng->Draw();

	//2D描画変換
	SetRenderTargets(1, &pRTV, nullptr);

	//UIマネージャー描画
	m_pUIStageManager->Draw();

	// スタート合図描画
	if (m_pStartText->GetAnimFlg())
	{
		m_pStartText->Draw();
	}

	// ポーズ描画
	if (m_pPause)
	{
		m_pPause->Draw();
	}

	// エフェクト描画
	m_pHitEffectMng->Draw();

}

/* ========================================
	デストラクタ
	----------------------------------------
	内容：破棄時に行う処理
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
CStage::~CStage()
{
	// =============== セーブ =====================
	m_Data.Save();	//ステージのデータセーブ

#if MODE_COORD_AXIS
// 軸線の表示
	CLine::Uninit();
#endif

	// =============== 終了 ===================
	SAFE_DELETE(m_pVs);
	SAFE_DELETE(m_pPlayer);
	SAFE_DELETE(m_pBox);
	SAFE_DELETE(m_pSlimeMng);
	SAFE_DELETE(m_pExplosionMng);
	SAFE_DELETE(m_pHitEffectMng);
	SAFE_DELETE(m_pCollision);
	SAFE_DELETE(m_pTexture);
	SAFE_DELETE(m_pScoreOHMng);
	SAFE_DELETE(m_pHealItemMng);
	SAFE_DELETE(m_pPause);
	SAFE_DELETE(m_pUIStageManager);
	SAFE_DELETE(m_pStartText);
}



/* ========================================
	ゲーム終了処理
	----------------------------------------
	内容：ゲーム終了時の処理
	----------------------------------------
	引数1：ステージ番号
	----------------------------------------
	戻値：なし
=========================================== */
void CStage::GameFinish()
{
	// ゲームが終了したか？
	if (m_pUIStageManager->GetStageFinishPtr()->GetGameEndFlg())
	{
		// =============== フラグ管理 =====================
		m_bFinish = true;	// タイトルシーン終了フラグON
	}
}


/* ========================================
	データ記録関数
	----------------------------------------
	内容：リザルト用にデータ記録
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
void CStage::RecordData()
{
	m_pUIStageManager->GetTotalScorePtr()->GameEndAddTotal();	// トータルスコアコンボ途中加算処理

	// =============== 退避 =====================
	m_Data.nTotalScore = m_pUIStageManager->GetTotalScore();				// スコア退避

	// =============== データ登録 =====================
	if (m_Data.nHighScore[m_nStageNum - 1] < m_Data.nTotalScore)	// ハイスコアを更新しているか？
	{
		m_Data.nHighScore[m_nStageNum - 1] = m_Data.nTotalScore;	// ハイスコア更新
	}
	m_Data.nAliveTime = m_pUIStageManager->GetTimerPtr()->GetErapsedTime();	// 経過時間退避
	m_Data.nMaxCombo = m_pUIStageManager->GetComboPtr()->GetMaxCombo();		// 最大コンボ数退避
	m_Data.bClearFlg = m_pUIStageManager->GetStageFinishPtr()->GetClearFlg();	// ゲームクリアしたか
	if (m_pSlimeMng)	//ヌルチェック
	{
		m_Data.nTotalKill = m_pSlimeMng->GetTotalKillCnt();					// 総討伐数退避
		m_pSlimeMng->GetKillCntArray(m_Data.nKill);							// スライム別討伐数退避

	}
	m_Data.nStageNum = m_nStageNum;	// プレイしたステージ番号
}