/* ========================================
	HEW/UniBoooom!!
	---------------------------------------
	ポーズオブジェ実装
	---------------------------------------
	PauseObj.cpp
	---------------------------------------
	作成者	takagi

	変更履歴
	・2023/12/09 制作 takagi
	・2023/12/10 制作進行 takagi
	・2023/12/17 引数参照化 takagi
	・2024/01/11 ブレンドステート修正に伴う透明度調整 takagi
	・2024/01/20 リファクタリング takagi
	・2024/01/21 コメント改修 takagi
	・2024/01/22 Draw()関数const化 takagi

========================================== */

// =============== インクルード ===================
#include "PauseObj.h"	//自身のヘッダ

// =============== 定数定義 ===================
const float MAX_OFFSET(50.0f);	//ズレの最大幅
const int MOVE_TIME(30);		//移動にかける時間

#define PAT_A (true)
#define PAT_B (true)
#define PAT_C (true)

/* ========================================
	コンストラクタ
	----------------------------------------
	内容：生成時に行う処理
	----------------------------------------
	引数1：const int& m_nWaitTime：待機時間
	----------------------------------------
	戻値：なし
=========================================== */
CPauseObj::CPauseObj(const int& nWaitTime)
	:m_fOffset(MAX_OFFSET)		//位置ズレ
	,m_fReach(0.0f)				//最終位置
	,m_pnWaitTime(nullptr)		//開始待機時間
	,m_pnRewaitTime(nullptr)	//終了待機時間
	,m_pnMoveTime(nullptr)		//移動時間
	,m_pnRemoveTime(nullptr)	//再移動時間
	,m_bDestroyed(false)		//破棄準備完了フラグ
{
	// =============== 動的確保 ===================
	m_pnMoveTime = new int(MOVE_TIME);	//移動時間初期化
	if (nWaitTime > 0)	//待機時間がある
	{
		m_pnWaitTime = new int(nWaitTime);	//待機時間初期化
	}
}

/* ========================================
	デストラクタ
	----------------------------------------
	内容：破棄時に行う処理
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
CPauseObj::~CPauseObj()
{
	// =============== 終了 ===================
	SAFE_DELETE(m_pnRemoveTime);	//移動時間削除
	SAFE_DELETE(m_pnMoveTime);		//移動時間削除
	SAFE_DELETE(m_pnRewaitTime);	//待機時間削除
	SAFE_DELETE(m_pnWaitTime);		//待機時間削除
}

/* ========================================
	更新関数
	----------------------------------------
	内容：更新処理
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
void CPauseObj::Update()
{
	// =============== 検査 ===================
	if (m_pnWaitTime)	//ヌルチェック
	{
		// =============== タイマ ===================
		if (*m_pnWaitTime > 0)
		{
			(*m_pnWaitTime)--;	//カウントダウン

		// =============== 終了 ===================
			return;	//処理中断		※CulculatePos()関数を呼ばないことでズレを表現する
		}
		else
		{
			SAFE_DELETE(m_pnWaitTime);	//タイマ削除
		}
	}
	// =============== 変数宣言 ===================
	TPos3d<float> fTemp;		//位置退避用

	// =============== 移動 ===================
	CulculatePos(fTemp);						//位置計算
	SetPos(fTemp);								//位置更新
	SetAlpha(1.0f - (m_fOffset / MAX_OFFSET));	//透明度更新

	// =============== 関数呼出 ===================
	C2dObject::Update();	//親関数呼び出し
}

/* ========================================
	描画関数
	----------------------------------------
	内容：描画処理
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：なし
=========================================== */
void CPauseObj::Draw() const
{
	// =============== 検査 ===================
	if (m_pnWaitTime)	//ヌルチェック
	{
		// =============== 終了 ===================
		return;	//処理中断
	}

	// =============== 関数呼出 ===================
	C2dObject::Draw();	//親関数呼び出し
}

/* ========================================
	目標値設定関数
	----------------------------------------
	内容：最終到達位置を設定する
	----------------------------------------
	引数1：const TPos3d<float>& fReach：最終地点
	----------------------------------------
	戻値：なし
=========================================== */
void CPauseObj::SetReach(const TPos3d<float>& fReach)
{
	// =============== 初期化 ===================
	m_fReach = fReach;	//到達地点初期化
}

/* ========================================
	破棄関数
	----------------------------------------
	内容：破棄処理
	----------------------------------------
	引数1：const int& nWaitTime：終了待機時間
	----------------------------------------
	戻値：なし
=========================================== */
void CPauseObj::Destroy(const int& nWaitTime)
{
	// =============== メモリ開放 ===================
	if (m_pnRewaitTime)	//ヌルチェック
	{
		SAFE_DELETE(m_pnWaitTime);		//待機時間削除
	}
	if (m_pnRemoveTime)	//ヌルチェック
	{
		SAFE_DELETE(m_pnRemoveTime);	//移動時間削除
	}

	// =============== 動的確保 ===================
	m_pnRemoveTime = new int(MOVE_TIME);		//移動時間初期化
	if (nWaitTime > 0)	//待機時間がある
	{
		m_pnRewaitTime = new int(nWaitTime);	//待機時間初期化
	}
}

/* ========================================
	破棄準備完了フラグ提供関数
	----------------------------------------
	内容：破棄準備が完了したかのフラグを返す
	----------------------------------------
	引数1：なし
	----------------------------------------
	戻値：破棄準備完了でtrue
=========================================== */
bool CPauseObj::IsDestroyed()
{
	// =============== 提供 ===================
	return m_bDestroyed;	//破棄準備完了フラグ
}

/* ========================================
	位置算出関数
	----------------------------------------
	内容：第一引数で受け取った位置を表す変数にズレを直接反映する。
	----------------------------------------
	引数1：TPos3d<float>& fPos：結果が格納される変数
	----------------------------------------
	戻値：なし
=========================================== */
void CPauseObj::CulculatePos(TPos3d<float>& fPos)
{
	// =============== 初期化 ===================
	fPos = m_fReach;	//最終目標位置

	// =============== 検査 ===================
	if (m_pnRewaitTime)	//ヌルチェック
	{
		// =============== タイマ ===================
		if (*m_pnRewaitTime > 0)
		{
			(*m_pnRewaitTime)--;	//カウントダウン

			// =============== 終了 ===================
			return;	//処理中断		※m_pnRemoveTimeを更新しないことでズレを表現する
		}
		else
		{
			SAFE_DELETE(m_pnRewaitTime);	//タイマ削除
		}
	}

	if (m_pnMoveTime)	//ヌルチェック
	{
		// =============== 算出 ===================
#if PAT_A
		m_fOffset = MAX_OFFSET * (*m_pnMoveTime) / MOVE_TIME;	//ズレ計算
#elif PAT_B
		m_fOffset = MAX_OFFSET * cosf(90.0f * (*m_pnMoveTime) / MOVE_TIME * 3.141592f / 180.0f);	//ズレ計算	cosθ(0 <= θ <= π/2)を用いた移動
#elif PAT_C
		m_fOffset = pow(pow(MAX_OFFSET, 0.5f) * (*m_pnMoveTime) / MOVE_TIME, 2.0f);	//ズレ計算	二次関数を用いた、速度が緩やかになっていく移動
#endif
		fPos.x += m_fOffset;	//ズレ適用

		// =============== タイマ ===================
		if (*m_pnMoveTime > 0)
		{
			(*m_pnMoveTime)--;	//カウントダウン
		}
		else
		{
			SAFE_DELETE(m_pnMoveTime);	//タイマ削除
		}
	}
	else
	{
		if (m_pnRemoveTime)	//ヌルチェック
		{
			// =============== 変数宣言 ===================
			int nTemp = MOVE_TIME - *m_pnRemoveTime;	//退避
#if PAT_A
			m_fOffset = MAX_OFFSET * nTemp / MOVE_TIME;	//ズレ計算
#elif PAT_B
			m_fOffset = MAX_OFFSET * cosf(90.0f * nTemp / MOVE_TIME * 3.141592f / 180.0f);	//ズレ計算	cosθ(0 <= θ <= π/2)を用いた移動
#elif PAT_C
			m_fOffset = pow(pow(MAX_OFFSET, 0.5f) * nTemp / MOVE_TIME, 2.0f);	//ズレ計算	二次関数を用いた、速度が緩やかになっていく移動
#endif
			fPos.x += m_fOffset;	//ズレ適用

			// =============== タイマ ===================
			if (*m_pnRemoveTime > 0)
			{
				(*m_pnRemoveTime)--;	//カウントダウン
			}
			else
			{
				SAFE_DELETE(m_pnRemoveTime);	//タイマ削除

				// =============== 破棄準備宣告 ===================
				m_bDestroyed = true;			//破棄準備完了
			}
		}
	}
}